/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 1.1.0
 * apibuilder 0.14.75 app.apibuilder.io/paintbatch-com/paint-batch-optimizer/1.1.0/http4s_0_20
 */
package com.paintbatch.server

import org.http4s.dsl.{io => _, _}
import org.http4s.implicits._
import cats.effect._
import cats.implicits._
import com.paintbatch.models.json._

private[server] trait Matchers[F[_]] extends Http4sDsl[F] {

  implicit lazy val queryParamDecodeBigDecimal: org.http4s.QueryParamDecoder[BigDecimal] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[BigDecimal](p => BigDecimal(p.value))("BigDecimal")

  implicit lazy val queryParamDecodeInstant: org.http4s.QueryParamDecoder[_root_.java.time.Instant] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.time.Instant](p => _root_.java.time.OffsetDateTime.parse(p.value).toInstant)("_root_.java.time.Instant")

  implicit lazy val queryParamDecodeLocalDate: org.http4s.QueryParamDecoder[_root_.java.time.LocalDate] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.time.LocalDate](p => _root_.java.time.LocalDate.parse(p.value))("_root_.java.time.LocalDate")

  implicit lazy val queryParamDecodeUUID: org.http4s.QueryParamDecoder[_root_.java.util.UUID] =
    org.http4s.QueryParamDecoder.fromUnsafeCast[_root_.java.util.UUID](p => _root_.java.util.UUID.fromString(p.value))("_root_.java.util.UUID")


  object ApiVersion {
    val ApiVersionMajor = {
      "X-Apidoc-Version-Major".ci
    }

    def apply(req: org.http4s.Message[F]): Boolean = req.headers.get(ApiVersionMajor) match {
      case Some(v) if v.value == "1" => true
      case _ => false
    }
  }


}

trait HealthcheckRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait GetHealthcheckResponse

  object GetHealthcheckResponse {
    case class HTTP200(value: com.paintbatch.models.Healthcheck, headers: Seq[org.http4s.Header] = Nil) extends GetHealthcheckResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends GetHealthcheckResponse
  }

  def getHealthcheck(
    _req: org.http4s.Request[F]
  ): F[GetHealthcheckResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpRoutes.of[F] {
    case _req @ GET -> Root / "_internal_" / "healthcheck" if apiVersionMatch(_req) =>
      getHealthcheck(_req).flatMap {
        case GetHealthcheckResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case GetHealthcheckResponse.UndocumentedResponse(response) => response
      }
    case _req @ GET -> Root / "_internal_" / "healthcheck" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

trait OptimizeRequestRoutes[F[_]] extends Matchers[F] {

  implicit def circeJsonDecoder[A](implicit decoder: _root_.io.circe.Decoder[A], sync: Sync[F]) = org.http4s.circe.jsonOf[F, A]
  implicit def circeJsonEncoder[A](implicit encoder: _root_.io.circe.Encoder[A], sync: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

  sealed trait PostOptimizeResponse

  object PostOptimizeResponse {
    case class HTTP200(value: String, headers: Seq[org.http4s.Header] = Nil) extends PostOptimizeResponse
    case class HTTP422(value: com.paintbatch.models.ReadableError, headers: Seq[org.http4s.Header] = Nil) extends PostOptimizeResponse
    case class UndocumentedResponse(response: F[org.http4s.Response[F]]) extends PostOptimizeResponse
  }

  def postOptimize(
    _req: org.http4s.Request[F],
    body: => org.http4s.DecodeResult[F, com.paintbatch.models.OptimizeRequest]
  ): F[PostOptimizeResponse]

  def apiVersionMatch(req: org.http4s.Message[F]): Boolean = ApiVersion(req)

  def service()(implicit sync: Sync[F]) = org.http4s.HttpRoutes.of[F] {
    case _req @ POST -> Root / "v2" / "optimize" if apiVersionMatch(_req) =>
      postOptimize(_req, _req.attemptAs[com.paintbatch.models.OptimizeRequest]).flatMap {
        case PostOptimizeResponse.HTTP200(value, headers) => Ok(value, headers: _*)
        case PostOptimizeResponse.HTTP422(value, headers) => UnprocessableEntity(value, headers: _*)
        case PostOptimizeResponse.UndocumentedResponse(response) => response
      }
    case _req @ POST -> Root / "v2" / "optimize" if !_req.headers.get(ApiVersion.ApiVersionMajor).isDefined =>
      BadRequest(s"Missing required request header: ${ApiVersion.ApiVersionMajor}.")
  }
}

     