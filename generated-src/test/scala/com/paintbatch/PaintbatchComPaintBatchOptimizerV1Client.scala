/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 1.1.0
 * apibuilder 0.14.75 app.apibuilder.io/paintbatch-com/paint-batch-optimizer/1.1.0/http4s_0_20
 */
package com.paintbatch.models {

  /**
   * range of customers preferences to choose from
   * 
   * @param paints paints the customer would be satisfied with
   */
  final case class Demand(
    paints: Seq[com.paintbatch.models.Paint]
  )

  /**
   * health of the service
   * 
   * @param status the health status of the service
   */
  final case class Healthcheck(
    status: com.paintbatch.models.Status
  )

  /**
   * paint batch optimizer request
   * 
   * @param colors number of different colours demanded by paint factory
   * @param customers number of customers
   * @param demands customers paint demands
   */
  final case class OptimizeRequest(
    colors: Int,
    customers: Int,
    demands: Seq[com.paintbatch.models.Demand]
  )

  /**
   * paint and its sheen
   * 
   * @param id paint identifier
   * @param sheen sheen of the paint
   */
  final case class Paint(
    id: Int,
    sheen: com.paintbatch.models.Sheen
  )

  /**
   * A simple human-readable error
   */
  final case class ReadableError(
    text: String
  )

  /**
   * available paint sheens
   */
  sealed trait Sheen extends _root_.scala.Product with _root_.scala.Serializable

  object Sheen {

    /**
     * matte sheen costs more than gloss
     */
    case object Matte extends Sheen { override def toString = "M" }
    /**
     * gloss sheen costs less than matte
     */
    case object Gloss extends Sheen { override def toString = "G" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Sheen

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Sheen] = scala.List(Matte, Gloss)

    private[this]
    val byName: Map[String, Sheen] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Sheen = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Sheen] = byName.get(value.toLowerCase)

  }

  /**
   * health of the service
   */
  sealed trait Status extends _root_.scala.Product with _root_.scala.Serializable

  object Status {

    /**
     * represents the service is live and accepting traffic
     */
    case object Ok extends Status { override def toString = "ok" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Status

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Status] = scala.List(Ok)

    private[this]
    val byName: Map[String, Status] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Status = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Status] = byName.get(value.toLowerCase)

  }

}

package com.paintbatch.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import com.paintbatch.models.json._

    // Make Scala 2.11 Either monadic
    private[paintbatch] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[paintbatch] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[paintbatch] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](uuid => uuid.toString)

    private[paintbatch] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.OffsetDateTime.parse(str).toInstant))

    private[paintbatch] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[paintbatch] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[paintbatch] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit val jsonDecoderPaintBatchOptimizerSheen: Decoder[com.paintbatch.models.Sheen] =
      Decoder.decodeString.map(com.paintbatch.models.Sheen(_))

    implicit val jsonEncoderPaintBatchOptimizerSheen: Encoder[com.paintbatch.models.Sheen] =
      Encoder.encodeString.contramap[com.paintbatch.models.Sheen](_.toString)

    implicit val jsonDecoderPaintBatchOptimizerStatus: Decoder[com.paintbatch.models.Status] =
      Decoder.decodeString.map(com.paintbatch.models.Status(_))

    implicit val jsonEncoderPaintBatchOptimizerStatus: Encoder[com.paintbatch.models.Status] =
      Encoder.encodeString.contramap[com.paintbatch.models.Status](_.toString)

    implicit def decodePaintBatchOptimizerDemand: Decoder[Demand] = Decoder.instance { c =>
     for {
        paints <- c.downField("paints").as[Seq[com.paintbatch.models.Paint]]
      } yield {
        Demand(
          paints = paints
        )
      }
    }

    implicit def encodePaintBatchOptimizerDemand: Encoder[Demand] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("paints" -> t.paints.asJson)
      ).flatten)
    }

    implicit def decodePaintBatchOptimizerHealthcheck: Decoder[Healthcheck] = Decoder.instance { c =>
     for {
        status <- c.downField("status").as[com.paintbatch.models.Status]
      } yield {
        Healthcheck(
          status = status
        )
      }
    }

    implicit def encodePaintBatchOptimizerHealthcheck: Encoder[Healthcheck] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("status" -> t.status.asJson)
      ).flatten)
    }

    implicit def decodePaintBatchOptimizerOptimizeRequest: Decoder[OptimizeRequest] = Decoder.instance { c =>
     for {
        colors <- c.downField("colors").as[Int]
        customers <- c.downField("customers").as[Int]
        demands <- c.downField("demands").as[Seq[com.paintbatch.models.Demand]]
      } yield {
        OptimizeRequest(
          colors = colors,
          customers = customers,
          demands = demands
        )
      }
    }

    implicit def encodePaintBatchOptimizerOptimizeRequest: Encoder[OptimizeRequest] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("colors" -> t.colors.asJson),
        Some("customers" -> t.customers.asJson),
        Some("demands" -> t.demands.asJson)
      ).flatten)
    }

    implicit def decodePaintBatchOptimizerPaint: Decoder[Paint] = Decoder.instance { c =>
     for {
        id <- c.downField("id").as[Int]
        sheen <- c.downField("sheen").as[com.paintbatch.models.Sheen]
      } yield {
        Paint(
          id = id,
          sheen = sheen
        )
      }
    }

    implicit def encodePaintBatchOptimizerPaint: Encoder[Paint] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("id" -> t.id.asJson),
        Some("sheen" -> t.sheen.asJson)
      ).flatten)
    }

    implicit def decodePaintBatchOptimizerReadableError: Decoder[ReadableError] = Decoder.instance { c =>
     for {
        text <- c.downField("text").as[String]
      } yield {
        ReadableError(
          text = text
        )
      }
    }

    implicit def encodePaintBatchOptimizerReadableError: Encoder[ReadableError] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("text" -> t.text.asJson)
      ).flatten)
    }
  }
}

package com.paintbatch {
import cats.effect._
import cats.implicits._
import io.circe.syntax._

  object Constants {

    val Namespace = "com.paintbatch"
    val UserAgent = "apibuilder 0.14.75 app.apibuilder.io/paintbatch-com/paint-batch-optimizer/1.1.0/http4s_0_20"
    val Version = "1.1.0"
    val VersionMajor = 1

  }

  class Client[F[_]: Sync](
    val baseUrl: org.http4s.Uri,
    auth: scala.Option[com.paintbatch.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: org.http4s.client.Client[F]
  ) extends interfaces.Client[F] {
    import org.http4s.Response
    import com.paintbatch.models.json._


    def healthchecks: Healthchecks[F] = Healthchecks

    def optimizeRequests: OptimizeRequests[F] = OptimizeRequests

    object Healthchecks extends Healthchecks[F] {
      override def getHealthcheck(
        requestHeaders: Seq[(String, String)] = Nil
      ): F[com.paintbatch.models.Healthcheck] = {
        val urlPath = Seq("_internal_", "healthcheck")

        _executeRequest[Unit, com.paintbatch.models.Healthcheck]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.com.paintbatch.Client.parseJson[F, com.paintbatch.models.Healthcheck]("com.paintbatch.models.Healthcheck", r)
          case r => Sync[F].raiseError(new com.paintbatch.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    object OptimizeRequests extends OptimizeRequests[F] {
      override def postOptimize(
        optimizeRequest: com.paintbatch.models.OptimizeRequest,
        requestHeaders: Seq[(String, String)] = Nil
      ): F[String] = {
        val urlPath = Seq("v2", "optimize")

        val (payload, formPayload) = (Some(optimizeRequest), None)

        _executeRequest[com.paintbatch.models.OptimizeRequest, String]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.com.paintbatch.Client.parseJson[F, String]("String", r)
          case r if r.status.code == 422 => _root_.com.paintbatch.Client.parseJson[F, com.paintbatch.models.ReadableError]("com.paintbatch.models.ReadableError", r).flatMap(body => Sync[F].raiseError(new com.paintbatch.errors.ReadableErrorResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new com.paintbatch.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 422"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: org.http4s.Request[F]): org.http4s.Request[F] = request

    implicit def circeJsonEncoder[F[_]: Sync, A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[F, A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response[F] => F[U]
    )(implicit encoder: io.circe.Encoder[T]): F[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case Right(m) => m
        case Left(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).toList.map { case (k, v) => org.http4s.Header(k, v) })

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request[F](method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header("Authorization", s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)
        else body.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)

      httpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {
    import cats.effect._

    implicit def circeJsonDecoder[F[_]: Sync, A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[F, A]

    def parseJson[F[_]: Sync, T](
      className: String,
      r: org.http4s.Response[F]
    )(implicit decoder: io.circe.Decoder[T]): F[T] = r.attemptAs[T].value.flatMap {
      case Right(value) => Sync[F].pure(value)
      case Left(error) => Sync[F].raiseError(new com.paintbatch.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client[F[_]] {
      def baseUrl: org.http4s.Uri
      def healthchecks: com.paintbatch.Healthchecks[F]
      def optimizeRequests: com.paintbatch.OptimizeRequests[F]
    }

  }

  trait Healthchecks[F[_]] {
    /**
     * GET health of service
     */
    def getHealthcheck(
      requestHeaders: Seq[(String, String)] = Nil
    ): F[com.paintbatch.models.Healthcheck]
  }

  trait OptimizeRequests[F[_]] {
    /**
     * POST minimum cost paint batch optimizer request
     */
    def postOptimize(
      optimizeRequest: com.paintbatch.models.OptimizeRequest,
      requestHeaders: Seq[(String, String)] = Nil
    ): F[String]
  }

  package errors {

    final case class ReadableErrorResponse(
      headers: org.http4s.Headers,
      status: Int,
      message: Option[String] = None,
      body: com.paintbatch.models.ReadableError
    ) extends Exception(s"HTTP $status${message.fold("")(m => s": $m")}"){
      lazy val readableError = body
    }

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}